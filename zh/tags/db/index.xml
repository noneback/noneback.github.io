<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DB on NoneBack</title>
    <link>https://noneback.github.io/zh/tags/db/</link>
    <description>Recent content in DB on NoneBack created by </description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>@NoneBack All rights reserved</copyright>
    <lastBuildDate>Wed, 10 Nov 2021 23:45:27 +0800</lastBuildDate><atom:link href="https://noneback.github.io/zh/tags/db/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Kylin概述</title>
      <link>https://noneback.github.io/zh/blog/zh/kylin%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Wed, 10 Nov 2021 23:45:27 +0800</pubDate>
      
      <guid>https://noneback.github.io/zh/blog/zh/kylin%E6%A6%82%E8%BF%B0/</guid>
      <description>&lt;p&gt;之前就想着能做一个有意思的毕设，奈何周围都没有合适的老师。之前在学院启动选题之前找好了一个感觉不错的老师，但没想到最后把我鸽了。不过之前老师的方向也并不是那么感兴趣，于是也就作罢。 最近学院的毕设流程启动了，也在选题里看到了感兴趣的题目，于是便联系老师接了下来。&lt;/p&gt;
&lt;p&gt;我选的题目是 &lt;strong&gt;《基于差分隐私的数据库查询算法的设计与实现》&lt;/strong&gt;，方向是Differential Privacy + OLAP，具体一点就是为Kylin添加Differential Privacy的Feature。&lt;/p&gt;
&lt;p&gt;总的来说就是如此，至于细节，也许在之后的博客中会写到。这是此系列博客的第一篇。&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;Kylin是一种分布式的OLAP数据仓库，基于Hbase和Parquet等列存数据库以及Hadoop和Spark等运算调度框架，支持超大规模数据的多维分析。&lt;/p&gt;
&lt;p&gt;它采用cube预计算的方法，把前台的实时查询变成了查询预计算结果，利用闲时的计算资源以及存储空间换取查询时间的优化，能极大的减少查询数据的时间。&lt;/p&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;在Kylin之前，一般使用Hadoop来对大规模数据进行批处理，并将结果存储在Hbase等列式存储中。其中OLAP相关的技术便是&lt;strong&gt;大数据并行处理&lt;/strong&gt;和&lt;strong&gt;列式存储&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;大规模并行处理&lt;/strong&gt;：实际上可以调用多台机其来并行处理计算任务，本质上是利用线性增长的计算资源来换取计算时间的线性下降。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;列式存储&lt;/strong&gt;：将记录按照列来存储。这方面主要是和OLAP的查询有关的，OLAP一般是对数据做统计等计算，一般都是同类型的列数据。列式存储使得查询时可以只访问需要的列并且可以充分利用顺序IO，提高性能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上两个技术使得Hadoop等平台上对于大数据的SQL查询达到了分钟级。但实际上，分钟级别的SQL查询依旧没法满足交互式分析的需要，效率依旧低下。&lt;/p&gt;
&lt;p&gt;其中本质的原因在于，&lt;strong&gt;无论是并行计算或者是列式存储，都没有改变查询本身的时间复杂度，没有改变查询时间和数据量的线性增长关系&lt;/strong&gt;。于是只能通过增加计算资源和利用局部性原理来对查询进行优化，这两种方法在数据量不断增长的情况下，都能明显的预见其成本上和理论上的瓶颈。&lt;/p&gt;
&lt;p&gt;基于此，Kylin提出&lt;strong&gt;预计算策略&lt;/strong&gt;，通过对不同的维度进行预计算生成多维&lt;strong&gt;cube&lt;/strong&gt;(实际上就是一个数据表),后续的查询直接基于预计算的结果进行。经过预计算,物化视图的规模就只由维度的基数来决定,而不再随着数据量的增长呈线性增长。&lt;/p&gt;
&lt;p&gt;这个策略本质上是&lt;strong&gt;利用空闲的计算资源以及额外的存储资源来换取查询时的响应速度，改变了查询时间与数据量之间的正比关系，从而提高效率&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;核心概念&#34;&gt;核心概念&lt;/h2&gt;
&lt;p&gt;Apache Kylin 的工作原理本质上是&lt;strong&gt;MOLAP(Multidimensional Online Analytical Processing)Cube,多维立方体分析技术&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;维度和度量&#34;&gt;维度和度量&lt;/h3&gt;
&lt;p&gt;维度指用于审视，聚合数据的一种角度，一般是数据记录的某一个属性。度量是基于数据计算出来的具体数值。通过维度来聚合计算出度量值 $$D_1,D_2,D_3,&amp;hellip; =&amp;gt; S_1,S_2，&amp;hellip;$$&lt;/p&gt;
&lt;h3 id=&#34;cube理论&#34;&gt;cube理论&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Data Cube，数据立方体&lt;/strong&gt;，其主要涉及构建和查询两种操作，构建时对原始数据建立多维度索引以及预计算，以加速查询。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Cuboid&lt;/strong&gt;: 指在某一维度组合下所计算出的数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Cube Segment&lt;/strong&gt;：Cube Segment是Cube的最小构建单位，一个Cube能被拆分为多个Cube Segment。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Cube增量构建&lt;/strong&gt;：一般来说，增量构建Cube时是基于时间属性来触发的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Cube基数&lt;/strong&gt;：Cube中所有维度的基数可以体现Cube的复杂度。复杂度高,Cube膨胀的概率会变高（IO,存储放大）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;架构设计&#34;&gt;架构设计&lt;/h2&gt;
&lt;p&gt;整个Kylin系统分为&lt;strong&gt;在线查询&lt;/strong&gt;和&lt;strong&gt;离线构建&lt;/strong&gt;两部分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2021/11/10/AoxY4POJHdqLheb.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;离线构建&lt;/strong&gt;：主要有数据源，构建引擎，存储引擎三大抽象。从数据源拉取数据构建Cube在存储到列式存储引擎中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;在线查询&lt;/strong&gt;：主要有接口层和查询引擎，对外部屏蔽Cube等底层概念。外部应用通过Rest API讲查询并转发给查询引擎，查询引擎查询与相关的数据返回结果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;作为一个OLAP引擎，Kylin充分利用了&lt;strong&gt;并行计算，列式存储，预计算&lt;/strong&gt;等优化技术提高其在线查询和离线构建性能，故而有如下几个明显的优缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;: 标准SQL接口，查询速度快,可拓展架构，BI系统友好&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;:依赖的外部系统过多，运维困难；预计算与Cube构建导致的IO和存储放大；数据模型以及Cube基数的局限。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://tech.meituan.com/2020/11/19/apache-kylin-practice-in-meituan.html&#34;&gt;美团 : Apache Kylin的实践与优化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://kylin.apache.org/cn/&#34;&gt;Kylin官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Kylin权威指南&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MySQL索引浅析</title>
      <link>https://noneback.github.io/zh/blog/zh/mysql%E7%B4%A2%E5%BC%95%E6%B5%85%E6%9E%90/</link>
      <pubDate>Sun, 21 Mar 2021 20:41:33 +0800</pubDate>
      
      <guid>https://noneback.github.io/zh/blog/zh/mysql%E7%B4%A2%E5%BC%95%E6%B5%85%E6%9E%90/</guid>
      <description>&lt;p&gt;&lt;strong&gt;数据库索引&lt;/strong&gt;，是DBMS中一个排序的数据结构，以协助快速查询、更新数据库中数据。一般来说，用于构建索引的数据结构有B树，B+树，哈希表等。&lt;/p&gt;
&lt;p&gt;MySQL中使用的是B+树构建索引。理由是B+树的一个节点可以存储更多的数据，并且B+树中，仅有叶子节点存储数据，非叶子节点仅存储索引，故而能将索引尽量多的保存在内存中，减少了树高，也降低了查询索引时进入磁盘IO的次数，极大提高查询的效率。&lt;/p&gt;
&lt;h2 id=&#34;innodb中的索引&#34;&gt;Innodb中的索引&lt;/h2&gt;
&lt;h3 id=&#34;聚簇索引与非聚簇索引&#34;&gt;聚簇索引与非聚簇索引&lt;/h3&gt;
&lt;p&gt;索引按照叶子节点保存的数据可分为聚簇索引和非聚簇索引两种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;聚簇索引&lt;/strong&gt;： 叶子节点直接保存了数据行，能够直接查询到用户数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非聚簇索引&lt;/strong&gt;：叶子节点保存了主键的值，通过&lt;strong&gt;回表&lt;/strong&gt;，查询主键索引查询用户数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Innodb引擎是利用主键索引组织表中的数据，每个表中一定需要有主键，利用主键构造B+树，得到主键索引，其中&lt;strong&gt;主键索引就是聚簇索引&lt;/strong&gt;，其余的&lt;strong&gt;二级索引都是非聚簇索引&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;联合索引&#34;&gt;联合索引&lt;/h3&gt;
&lt;p&gt;联合索引是由多个字段组成的索引。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;create&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;index&lt;/span&gt; index_name &lt;span style=&#34;color:#66d9ef&#34;&gt;on&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;table_name&lt;/span&gt; (col_1,col_2...)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;相比与单值索引，主要区别在于其遵守&lt;strong&gt;最左前缀匹配原则&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最左前缀匹配原则：使用联合索引时，索引按照索引字段从左到右的顺序对索引值进行排序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;使用索引优化查询性能&#34;&gt;使用索引优化查询性能&lt;/h2&gt;
&lt;p&gt;由于索引有序，故而能极大的提高查询的效率。使用索引进行查询优化时要遵守一些原则&lt;/p&gt;
&lt;h3 id=&#34;最左前缀匹配原则&#34;&gt;最左前缀匹配原则&lt;/h3&gt;
&lt;p&gt;使用联合索引时，索引按照索引字段从左到右的顺序对索引值进行排序。查询索引时，我们也需要满足最左前缀匹配，否则数据的排列是无序的，会导致全表的扫描。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用 col1,col2,col3构建索引，按照最左前缀匹配，在设计查询语句时我们需要按照col1 -&amp;gt; col2 -&amp;gt; col3的顺序去设计判断条件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;select * from table_name where col1 = 1 and col2 = 2;&lt;/code&gt; 走索引&lt;/p&gt;
&lt;p&gt;&lt;code&gt;select * from table_name where col2 = 1 and col3 = 2;&lt;/code&gt; 不走索引&lt;/p&gt;
&lt;p&gt;注：&lt;strong&gt;MySQL查询时，会一直向右匹配直到遇到范围查询(&amp;gt;、&amp;lt;、between、like)就停止匹配&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;索引覆盖原则&#34;&gt;索引覆盖原则&lt;/h3&gt;
&lt;p&gt;索引覆盖，指通过查询索引可以直接查询到需要的值，而不需要回表等操作。设计合理的索引，可以减少回表的次数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对联合索引(col1,col2,col3)&lt;/p&gt;
&lt;p&gt;查询语句 &lt;code&gt;select col1,col2,col3 from test where col1=1 and col2=2&lt;/code&gt;可以直接查到col1-col3的值，无需回表，因为他们的值已经被保存在二级索引中了。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>实现简单的SQL数据库--前端</title>
      <link>https://noneback.github.io/zh/blog/zh/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%89%8D%E7%AB%AF/</link>
      <pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://noneback.github.io/zh/blog/zh/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%89%8D%E7%AB%AF/</guid>
      <description>&lt;p&gt;一直想去完成pingcap的tanlent Plan里面的tinySql路径，但一直没有开始。最近论坛上发现了pingcap创始人的tanlent plan入坑贴，下面的学长提示了这个从零实现数据库博客入门比较合适，于是写下这个博客。&lt;/p&gt;
&lt;h2 id=&#34;前端&#34;&gt;前端&lt;/h2&gt;
&lt;p&gt;与编译器类似，一个数据库软件也分为前端和后端。前端部分主要是SQL语句的解析以及一个REPL。&lt;/p&gt;
&lt;h3 id=&#34;获取tokens&#34;&gt;获取tokens&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;token&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
 &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;
 &lt;span style=&#34;color:#a6e22e&#34;&gt;kind&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;tokenKind&lt;/span&gt;
 &lt;span style=&#34;color:#a6e22e&#34;&gt;loc&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;location&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;模拟cursor扫描语句，将sql语句解析为一个一个token，token中包括了&lt;strong&gt;单词的种类，位置，值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;获取单个token时，每次扫描结束，如果成功，更新光标，并返回一个新token地址以及更新后的光标位置，ok=true。&lt;/p&gt;
&lt;p&gt;如果失败，则返回nil,传入的初始化的光标位置不变，ok=false。&lt;/p&gt;
&lt;p&gt;最终处理所有语句，得到token地址数组&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 主要流程
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lex&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;source&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) ([]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;token&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;) {
 &lt;span style=&#34;color:#a6e22e&#34;&gt;tokens&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;token&lt;/span&gt;{}
 &lt;span style=&#34;color:#a6e22e&#34;&gt;cur&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cursor&lt;/span&gt;{}

 &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cur&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;pointer&lt;/span&gt; &amp;lt; uint(len(&lt;span style=&#34;color:#a6e22e&#34;&gt;source&lt;/span&gt;)) {
  &lt;span style=&#34;color:#a6e22e&#34;&gt;lexers&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#a6e22e&#34;&gt;lexer&lt;/span&gt;{&lt;span style=&#34;color:#a6e22e&#34;&gt;lexKeyword&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;lexSymbol&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;lexString&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;lexNumeric&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;lexIdentifier&lt;/span&gt;}
  &lt;span style=&#34;color:#a6e22e&#34;&gt;isMatched&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;l&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lexers&lt;/span&gt; {
   &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;token&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;newCursor&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;l&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;source&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;cur&lt;/span&gt;); &lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;cur&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;newCursor&lt;/span&gt;

    &lt;span style=&#34;color:#75715e&#34;&gt;// Omit nil tokens for valid, but empty syntax like newlines
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;token&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
     &lt;span style=&#34;color:#a6e22e&#34;&gt;tokens&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;tokens&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;token&lt;/span&gt;)
    }
    &lt;span style=&#34;color:#a6e22e&#34;&gt;isMatched&lt;/span&gt; = &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;
   }
  }

  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;isMatched&lt;/span&gt; {
   &lt;span style=&#34;color:#75715e&#34;&gt;// match the next one
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
  }

  &lt;span style=&#34;color:#a6e22e&#34;&gt;hint&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len(&lt;span style=&#34;color:#a6e22e&#34;&gt;tokens&lt;/span&gt;) &amp;gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
   &lt;span style=&#34;color:#a6e22e&#34;&gt;hint&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; after &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;tokens&lt;/span&gt;[len(&lt;span style=&#34;color:#a6e22e&#34;&gt;tokens&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;].&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;
  }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Errorf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Unable to lex token%s, at %d:%d&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;hint&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;cur&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;loc&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;row&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;cur&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;loc&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;col&lt;/span&gt;)
 }
 &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;tokens&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;获得ast&#34;&gt;获得Ast&lt;/h3&gt;
&lt;p&gt;第二步，从tokens中，解析出一个抽象语法树。&lt;/p&gt;
&lt;p&gt;Ast有statement[]组成，目前的解析器只解析select，insert，create三种语句。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Ast&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
 &lt;span style=&#34;color:#a6e22e&#34;&gt;Statement&lt;/span&gt; []&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Statement&lt;/span&gt;
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Statement&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
 &lt;span style=&#34;color:#a6e22e&#34;&gt;SelectStatement&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;SelectStatement&lt;/span&gt;
 &lt;span style=&#34;color:#a6e22e&#34;&gt;CreateStatement&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;CreateStatement&lt;/span&gt;
 &lt;span style=&#34;color:#a6e22e&#34;&gt;InsertStatement&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;InsertStatement&lt;/span&gt;
 &lt;span style=&#34;color:#a6e22e&#34;&gt;Kind&lt;/span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;AstKind&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;解析的思路是按照不同的sql语句，分析出相应的语法成分，最后形成最后的语法树&lt;/p&gt;
&lt;h4 id=&#34;select语句&#34;&gt;SELECT语句&lt;/h4&gt;
&lt;p&gt;语法成分：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SELECT  ${ expression[] }$  FROM $ tableName $&lt;/p&gt;
&lt;p&gt;example：select id,age,name from students&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.解析出keyword SELECT&lt;/p&gt;
&lt;p&gt;2.解析expression[]&lt;/p&gt;
&lt;p&gt;3.解析出keyword FROM&lt;/p&gt;
&lt;p&gt;4.解析identifier  $tableName$&lt;/p&gt;
&lt;p&gt;其中重点在于对expressions的理解与解析&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// parse the token at cursor and return an expression containing literal val and its kind
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;parseExpression&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;tokens&lt;/span&gt; []&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;token&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;initialCursor&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;token&lt;/span&gt;) (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;expression&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;uint&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;) {
 &lt;span style=&#34;color:#a6e22e&#34;&gt;cursor&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;initialCursor&lt;/span&gt;

 &lt;span style=&#34;color:#a6e22e&#34;&gt;kinds&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#a6e22e&#34;&gt;tokenKind&lt;/span&gt;{&lt;span style=&#34;color:#a6e22e&#34;&gt;identifierKind&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;numericKind&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;stringKind&lt;/span&gt;}
    
 &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;kind&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;kinds&lt;/span&gt; {
  &lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;newCursor&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;parseToken&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;tokens&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;cursor&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;kind&lt;/span&gt;)
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt; {
   &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;expression&lt;/span&gt;{
    &lt;span style=&#34;color:#a6e22e&#34;&gt;literal&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt;,
    &lt;span style=&#34;color:#a6e22e&#34;&gt;kind&lt;/span&gt;:    &lt;span style=&#34;color:#a6e22e&#34;&gt;literalKind&lt;/span&gt;,
   }, &lt;span style=&#34;color:#a6e22e&#34;&gt;newCursor&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
  }
 }

 &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;initialCursor&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;expression 只包括了stringKind，numericKind，identifierKind的字符集合。parseexpression读入一个token，如果cursor超出了tokens的长度或者Kind不是这三种，则返回错误的结果，遇到分隔符delimiter则正常返回。&lt;/p&gt;
&lt;h4 id=&#34;create语句&#34;&gt;CREATE语句&lt;/h4&gt;
&lt;p&gt;语法成分&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CREATE TABLE  $tableName$ ( $columnDef$ )&lt;/p&gt;
&lt;p&gt;example:CREATE TABLE students(id string, age int, name string)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.解析出keyword CREATE&lt;/p&gt;
&lt;p&gt;2.解析出keyword TABLE&lt;/p&gt;
&lt;p&gt;3.解析identifier  $tableName$&lt;/p&gt;
&lt;p&gt;4.解析 symbol &lt;em&gt;(&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;5.解析$columndef$&lt;/p&gt;
&lt;p&gt;6.解析symbol &lt;em&gt;)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;解析CREATE的语句关键是对$columnDef$的解析&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//column
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;columnDefinition&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
 &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;     &lt;span style=&#34;color:#a6e22e&#34;&gt;token&lt;/span&gt;
 &lt;span style=&#34;color:#a6e22e&#34;&gt;datatype&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;token&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;解析columnDefinitions&lt;/p&gt;
&lt;p&gt;1.循环解析token，直到cur超出tokens范围或者解析出现错误&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;首先解析identifier $name$,keyword $datatype$&lt;/li&gt;
&lt;li&gt;解析分隔符 symbol &lt;em&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// parse col def
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;parseColumnDefinitions&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;tokens&lt;/span&gt; []&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;token&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;initialCursor&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;delimiter&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;token&lt;/span&gt;) (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;[]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;columnDefinition&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;uint&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;) {
 &lt;span style=&#34;color:#a6e22e&#34;&gt;cursor&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;initialCursor&lt;/span&gt;

 &lt;span style=&#34;color:#a6e22e&#34;&gt;cds&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;columnDefinition&lt;/span&gt;{}
 &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cursor&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; uint(len(&lt;span style=&#34;color:#a6e22e&#34;&gt;tokens&lt;/span&gt;)) {
   &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;initialCursor&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
  }

  &lt;span style=&#34;color:#75715e&#34;&gt;// Look for a delimiter
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;current&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;tokens&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;cursor&lt;/span&gt;]
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;delimiter&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;equals&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;current&lt;/span&gt;) {
   &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;
  }

  &lt;span style=&#34;color:#75715e&#34;&gt;// Look for a comma
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// col devided by comma
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len(&lt;span style=&#34;color:#a6e22e&#34;&gt;cds&lt;/span&gt;) &amp;gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; {
   &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; !&lt;span style=&#34;color:#a6e22e&#34;&gt;expectToken&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;tokens&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;cursor&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;tokenFromSymbol&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;commaSymbol&lt;/span&gt;)) {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;helpMessage&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;tokens&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;cursor&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Expected comma&amp;#34;&lt;/span&gt;)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;initialCursor&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
   }

   &lt;span style=&#34;color:#a6e22e&#34;&gt;cursor&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;
  }

  &lt;span style=&#34;color:#75715e&#34;&gt;// Look for a column name
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;newCursor&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;parseToken&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;tokens&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;cursor&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;identifierKind&lt;/span&gt;)
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; !&lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt; {
   &lt;span style=&#34;color:#a6e22e&#34;&gt;helpMessage&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;tokens&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;cursor&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Expected column name&amp;#34;&lt;/span&gt;)
   &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;initialCursor&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
  }
  &lt;span style=&#34;color:#a6e22e&#34;&gt;cursor&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;newCursor&lt;/span&gt;

  &lt;span style=&#34;color:#75715e&#34;&gt;// Look for a column type
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;//like col_name type
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;ty&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;newCursor&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;parseToken&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;tokens&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;cursor&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;keywordKind&lt;/span&gt;)
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; !&lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt; {
   &lt;span style=&#34;color:#a6e22e&#34;&gt;helpMessage&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;tokens&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;cursor&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Expected column type&amp;#34;&lt;/span&gt;)
   &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;initialCursor&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
  }
  &lt;span style=&#34;color:#a6e22e&#34;&gt;cursor&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;newCursor&lt;/span&gt;

  &lt;span style=&#34;color:#a6e22e&#34;&gt;cds&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;cds&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;columnDefinition&lt;/span&gt;{
   &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;:     &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;,
   &lt;span style=&#34;color:#a6e22e&#34;&gt;datatype&lt;/span&gt;: &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ty&lt;/span&gt;,
  })
 }

 &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cds&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;cursor&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;insert语句&#34;&gt;INSERT语句&lt;/h4&gt;
&lt;p&gt;语法成分&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;INSERT INTO VALUES ( $expression[]$ )&lt;/p&gt;
&lt;p&gt;example: INSERT INTO VALUES(1,20,Kate)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.解析keyword INSERT&lt;/p&gt;
&lt;p&gt;2.解析keyword INTO&lt;/p&gt;
&lt;p&gt;3.解析keyword VALUES&lt;/p&gt;
&lt;p&gt;4.解析symbol &lt;em&gt;(&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;5.解析 $expression[]$&lt;/p&gt;
&lt;p&gt;6.解析symbol &lt;em&gt;)&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;主函数parse&#34;&gt;主函数parse&lt;/h3&gt;
&lt;p&gt;主函数分号作为分隔符解析三种sql语句&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Parse&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;source&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Ast&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;) {
 &lt;span style=&#34;color:#a6e22e&#34;&gt;tokens&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lex&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;source&lt;/span&gt;)
 &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;
 }

 &lt;span style=&#34;color:#a6e22e&#34;&gt;ast&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Ast&lt;/span&gt;{}
 &lt;span style=&#34;color:#a6e22e&#34;&gt;cursor&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; uint(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
 &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cursor&lt;/span&gt; &amp;lt; uint(len(&lt;span style=&#34;color:#a6e22e&#34;&gt;source&lt;/span&gt;)) {
  &lt;span style=&#34;color:#75715e&#34;&gt;//parse each statement divide by &amp;#39;;&amp;#39; and add to ast
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;stmt&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;newCursor&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;parseStatement&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;tokens&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;cursor&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;tokenFromSymbol&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;semicolonSymbol&lt;/span&gt;))
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; !&lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt; {
   &lt;span style=&#34;color:#a6e22e&#34;&gt;helpMessage&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;tokens&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;cursor&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Expected statement&amp;#34;&lt;/span&gt;)
   &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;errors&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;New&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Failed to parse,exit&amp;#34;&lt;/span&gt;)
  }
  &lt;span style=&#34;color:#a6e22e&#34;&gt;cursor&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;newCursor&lt;/span&gt;
  &lt;span style=&#34;color:#a6e22e&#34;&gt;ast&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Statement&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;ast&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Statement&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;stmt&lt;/span&gt;)

  &lt;span style=&#34;color:#a6e22e&#34;&gt;atLeastOneSemicolon&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;expectToken&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;tokens&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;cursor&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;tokenFromSymbol&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;semicolonSymbol&lt;/span&gt;)) {
   &lt;span style=&#34;color:#a6e22e&#34;&gt;cursor&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;atLeastOneSemicolon&lt;/span&gt; = &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
  }

  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; !&lt;span style=&#34;color:#a6e22e&#34;&gt;atLeastOneSemicolon&lt;/span&gt; {
   &lt;span style=&#34;color:#a6e22e&#34;&gt;helpMessage&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;tokens&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;cursor&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Expected semi-colon delimiter between statements&amp;#34;&lt;/span&gt;)
   &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;errors&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;New&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Missing semi-colon between statements&amp;#34;&lt;/span&gt;)
  }
 }
 &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ast&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;简易后端&#34;&gt;简易后端&lt;/h2&gt;
&lt;p&gt;本文重点在于解析sql语句以及前端的编写思路，这次仅仅使用一个map in memory 作为后端。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// backend in memory
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MemoryBackend&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
 &lt;span style=&#34;color:#a6e22e&#34;&gt;tables&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;table&lt;/span&gt;
}

&lt;span style=&#34;color:#75715e&#34;&gt;// table
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
 &lt;span style=&#34;color:#a6e22e&#34;&gt;columns&lt;/span&gt;     []&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;
 &lt;span style=&#34;color:#a6e22e&#34;&gt;columnTypes&lt;/span&gt; []&lt;span style=&#34;color:#a6e22e&#34;&gt;ColumnType&lt;/span&gt;
 &lt;span style=&#34;color:#a6e22e&#34;&gt;rows&lt;/span&gt;        [][]&lt;span style=&#34;color:#a6e22e&#34;&gt;MemoryCell&lt;/span&gt;
}

&lt;span style=&#34;color:#75715e&#34;&gt;//Result
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Results&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
 &lt;span style=&#34;color:#a6e22e&#34;&gt;Columns&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
  &lt;span style=&#34;color:#a6e22e&#34;&gt;Type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ColumnType&lt;/span&gt;
  &lt;span style=&#34;color:#a6e22e&#34;&gt;Name&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;
 }
 &lt;span style=&#34;color:#a6e22e&#34;&gt;Rows&lt;/span&gt; [][]&lt;span style=&#34;color:#a6e22e&#34;&gt;Cell&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;repl&#34;&gt;REPL&lt;/h2&gt;
&lt;p&gt;下面是一个简单的REPL设计思路&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
 &lt;span style=&#34;color:#a6e22e&#34;&gt;mb&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;NewMemoryBackend&lt;/span&gt;()

 &lt;span style=&#34;color:#a6e22e&#34;&gt;reader&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bufio&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;NewReader&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Stdin&lt;/span&gt;)
 &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Welcome to &amp;#34;&lt;/span&gt;)
 &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; {
  &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Print&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;# &amp;#34;&lt;/span&gt;)
  &lt;span style=&#34;color:#a6e22e&#34;&gt;text&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;reader&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ReadString&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;)
  &lt;span style=&#34;color:#a6e22e&#34;&gt;text&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;strings&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Replace&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;text&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)

  &lt;span style=&#34;color:#a6e22e&#34;&gt;ast&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Parse&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;text&lt;/span&gt;)
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
   panic(&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
  }

  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;stmt&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ast&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Statements&lt;/span&gt; {
   &lt;span style=&#34;color:#66d9ef&#34;&gt;switch&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;stmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Kind&lt;/span&gt; {
   &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CreateKind&lt;/span&gt;:
    
   &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;InsertKind&lt;/span&gt;:
    
   &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SelectKind&lt;/span&gt;:
      
   }
 }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其他剩余代码见&lt;a href=&#34;https://github.com/noneback/gosql&#34;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://notes.eatonphil.com/database-basics.html&#34;&gt;Writing a SQL database from scratch in Go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.postgresql.org/docs/current/sql-syntax-lexical.html&#34;&gt;PostgreSQL documentation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/eatonphil/gosql&#34;&gt;gosql&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>